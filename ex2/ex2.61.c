#include <stdio.h>

/*
  写一个C表达式，在下列描述的条件下产生1，而在其他情况下得到0.假设X是int类型。
  代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（==）和不相等（==）测试。

  注： 我没有利用题目中提及到的“有符号数的右移是算术右移”这一条件来实现，因为书中前面也提到“C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移----算术右移或者逻辑右移都可以”，所以我这里尝试另一种方法。
 */
int main(int argc, char const* argv[])
{
  int x;
  //A. x的任何位都等于1
  // !(x+1)
  printf("x的任何位都等于1，测试:\n");
  x = ~0;
  printf("~0   -> %d\n", !(x+1));
  x = x+1;
  printf("~0+1 -> %d\n", !(x+1));
  //B. x的任何位都等于0
  // !x
  printf("x的任何位都等于0，测试:\n");
  x = 0;
  printf("0    -> %d\n", !x);
  x = 0x1000;
  printf("0x00001000    -> %d\n", !x);
  //C. x的最低有效字节中的位都等于1
  // !((x+1)&0xFF)
  printf("x的最低有效字节中的位都等于1\n");
  x = 0xFF;
  printf("0xFF -> %d\n", !((x+1)&0xFF));
  x = 0;
  printf("0 -> %d\n", !((x+1)&0xFF));
  //D. x的最高有效字节中的位都等于0
  // !(x&(0xFF<<((sizeof(int)-1)<<3)))
  printf("x的最高有效字节中的位都等于0\n");
  x = 0;
  printf("0 -> %d\n", !(x&(0xFF<<((sizeof(int)-1)<<3))));
  x = ~0;
  printf("~0 -> %d\n", !(x&(0xFF<<((sizeof(int)-1)<<3))));
}
